#include "kmean.h"

XDokmean dokmean;
XDokmean_Config *dokmean_cfg;
XAxiDma axiDMA;
XAxiDma_Config *axiDMA_cfg;
XTmrCtr Ttimer;

static char *Log_File;
static FATFS  FS_instance;
static FIL file_in;
/*
float data_set[N_POINTS][N_FEATURES];
int result[N_POINTS+1];
float centroids[N_CLUSTER][N_FEATURES];
int endip[2];
int in_index[N_CLUSTER];
*/

float* data_set;// = (float*)malloc(N_POINTS*N_FEATURES*sizeof(float));
int* res;
float* centroids;
int* endip;
int* in_index;

float* centroids1;
float* centroids2;
float* centroids3;
float* centroids4;

int* endip1;
int* endip2;
int* endip3;
int* endip4;

int* shared_mem = (int*) 0x40000000;

void initPeripherals(){

	dokmean_cfg = XDokmean_LookupConfig(XPAR_XDOKMEAN_0_DEVICE_ID);
	if(dokmean_cfg){
		int status = XDokmean_CfgInitialize(&dokmean, dokmean_cfg);
		if(status != XST_SUCCESS){
			printf("Error initializing dokmean core \n");
		}
	}

	axiDMA_cfg = XAxiDma_LookupConfig(XPAR_AXIDMA_0_DEVICE_ID);
	if(axiDMA_cfg){
		int stat = XAxiDma_CfgInitialize(&axiDMA,axiDMA_cfg);
		if(stat != XST_SUCCESS){
			printf("error dma init \n");
		}
	}

	XAxiDma_IntrDisable(&axiDMA, XAXIDMA_IRQ_ALL_MASK, XAXIDMA_DEVICE_TO_DMA);
	XAxiDma_IntrDisable(&axiDMA, XAXIDMA_IRQ_ALL_MASK, XAXIDMA_DMA_TO_DEVICE);

	XTmrCtr_Initialize(&Ttimer, XPAR_TMRCTR_0_DEVICE_ID);
}

void read_dataset(float* data_set){
	FRESULT f_in;
	Log_File = (char *)FILE_NAME;
	f_in = f_open(&file_in, Log_File,FA_READ);
	if (f_in!= FR_OK) {
		printf("%d \n", f_in);
		printf("File  INPUT_FILE  not found\n");
	}
	printf("File  ok \n");

	int feature = 0;
	int point = 0;
	char number[N_digits];
	int index = 0;
	static char * buf;
	buf = (char*) malloc (sizeof(char)*CHUNK);
	int n_read = 0 ;
	f_read(&file_in, buf, CHUNK, &n_read);
    while(n_read>0){
    	for(int j = 0; j < n_read; j++){
    		if(buf[j]==','){
    			data_set[point*feature+feature] = (float)atof(number);
    	        index = 0;
    	        if(feature < N_FEATURES-1){
    	        	feature++;}
    	        else{
    	            break;}
    	        }else{
    	        	if(buf[j] == (char)0x0a){
    	        		data_set[point*feature+feature] = (float)atof(number);
    	        		feature = 0;
    	        		index = 0;
    	        		if(point < N_POINTS-1){
    	        			point++;}
    	        		else{break;}
    	           }else{
    	        	   if(index<N_digits){
    	        		   number[index] = buf[j];
    	        		   index++;
    	        	   }
    	           }
    	        }
    	      }
    	if(feature > N_FEATURES-1 || point > N_POINTS-1)
    	{
    		break;
    	}else{
    	f_read(&file_in, buf, CHUNK, &n_read);
    	}
    }

	f_close(&file_in);
	free (buf);
}

void show_dataset(float* data, int row){
	for(int i = 0; i <row ; i++){
		for(int j=0 ; j < N_FEATURES ; j++){
			printf("%f ,", data[i*j+j]);
		}
		printf("\n%d\n", i);
	}
}

void cluster_index(int* index){
	for(int j=0;j<N_CLUSTER;j++){
		index[j] = N_CLUSTER+5;
	}
	int random = 0;
	int i = 0;
	int is_inarray = 0;
	while(i<N_CLUSTER){
		random = rand() % N_POINTS;
		is_inarray = 0;
		for(int j=0;j<N_CLUSTER;j++){
			if(random == index[j]){
				is_inarray = 1;
				break;
			}
		}
		if(!is_inarray){
			index[i] = random;
			i++;
		}
	}
}

int kmeans(){

	uint32_t startTime = 0;
	uint32_t startTime_c = 0;
	float time = 0;

	/********** load data **********/
	startTime = start_time(&Ttimer);
	read_dataset(data_set);
	printf("read done \n");

	for(int i=0; i<N_POINTS+1 ; i++){
		res[i]=i;
	}

	startTime_c = XTmrCtr_GetValue(&Ttimer,0);
	/********** generate random cluster index **********/
	cluster_index(in_index);

	/********** initialize cluster centroid ***********/
	for(int i=0; i<N_CLUSTER; i++){
		for(int j=0; j<N_FEATURES; j++){
		  centroids[i*j+j] =  data_set[in_index[i]*j+j];
		}
	 }

	for(int i=0; i<N_POINTS ; i++){
		printf("%d,", res[i]);
	}


	printf("\n");
	int* addRes = &res[0];
	int finish = 0;
	while(finish == 0){
		finish = 1;

		Xil_DCacheFlushRange((u32)data_set, (N_POINTS)*N_FEATURES*sizeof(float));
		Xil_DCacheFlushRange((u32)centroids, (N_CLUSTER)*N_FEATURES*sizeof(float));
		Xil_DCacheFlushRange((u32)res, (N_POINTS)*sizeof(int));

		shared_mem[M1_DONE] = 0;
		shared_mem[M1_START] = 1;
		Xil_DCacheFlushRange((u32)shared_mem, 100*sizeof(int));
		printf("++++++++++++++++++++++++++++++++=\n");
		for(int i =1; i< 101 ; i++){
			printf("%d,", shared_mem[i-1]);
			if(i%10 == 0){
				printf("\n");
			}
		}
		printf("\n");
		int a = (int)shared_mem[M1_START];
		while(1){
			int done = shared_mem[M1_DONE];
			if(done == 1){
				shared_mem[M1_DONE] = 0;
				break;
			}
			usleep(1);
		}

		Xil_DCacheInvalidateRange((u32) centroids1, N_CLUSTER*N_FEATURES*sizeof(float));
		Xil_DCacheInvalidateRange((u32) endip1, (N_CLUSTER)*N_FEATURES*sizeof(float));
		Xil_DCacheInvalidateRange((u32) res, (N_POINTS)*sizeof(int));

		finish = endip1[0];

		if(finish == 0){
			for(int i=0; i<N_CLUSTER; i++){
				for(int j=0; j<N_FEATURES; j++){
				  centroids[i*j+j] = centroids1[i*j+j];
				  printf("%f,",centroids1[i*j+j]);
				}
			 }
		}

		for(int i=0; i<N_POINTS ; i++){
			printf("%d,", res[i]);
		}
		printf("\n");


	}




		/*
		shared_mem[M2_DONE] = 0;
		shared_mem[PCLUS] = (float*) &centroids;
		shared_mem[PRESU2] = (float*) &centroids4;

		shared_mem[M3_DONE] = 0;
		shared_mem[PCLUS] = (float*) &centroids;
		shared_mem[PRESU3] = (float*) &centroids5;

		shared_mem[M4_DONE] = 0;
		shared_mem[PCLUS] = (float*) &centroids;
		shared_mem[PRESU3] = (float*) &centroids6;  */

		/*** start processors ***/
		/*
		shared_mem[M2_START] = 1;
		shared_mem[M3_START] = 1;
		shared_mem[M4_START] = 1;
		Xil_DCacheFlushRange((u32)shared_mem, 100*sizeof(int));


		while(1){
			int done = shared_mem[M2_DONE];
			if(done == 1){
				break;
			}
			usleep(1);
		}

		while(1){
			int done = shared_mem[M3_DONE];
			if(done == 1){
				break;
			}
			usleep(1);
		}

		while(1){
			int done = shared_mem[M4_DONE];
			if(done == 1){
				break;
			}
			usleep(1);
		}


		show_dataset(centroids3, N_CLUSTER);
		printf("finito \n");

		Xil_DCacheInvalidateRange((u32) centroids4, N_CLUSTER*N_FEATURES*sizeof(float));
		show_dataset(centroids4, N_CLUSTER);
		printf("finito 2\n");

		Xil_DCacheInvalidateRange((u32) centroids5, N_CLUSTER*N_FEATURES*sizeof(float));
		show_dataset(centroids5, N_CLUSTER);
		printf("finito 3\n");

		Xil_DCacheInvalidateRange((u32) centroids6, N_CLUSTER*N_FEATURES*sizeof(float));
		show_dataset(centroids6, N_CLUSTER);
		printf("finito 4\n");
		*/

	time = get_time(&Ttimer, startTime, startTime_c);

	return 0;
}

int main(){

	data_set = (float*)malloc(N_POINTS*N_FEATURES*sizeof(float));
	res = (int*) malloc(N_POINTS*sizeof(int));
	centroids = (float*) malloc(N_CLUSTER*N_FEATURES*sizeof(float));
	endip = (int*) malloc(2*sizeof(int));
	in_index = (int*) malloc(N_CLUSTER*sizeof(int));

	centroids1 = (float*) malloc(N_CLUSTER*N_FEATURES*sizeof(float));
	centroids2 = (float*) malloc(N_CLUSTER*N_FEATURES*sizeof(float));
	centroids3 = (float*) malloc(N_CLUSTER*N_FEATURES*sizeof(float));
	centroids4 = (float*) malloc(N_CLUSTER*N_FEATURES*sizeof(float));

	endip1 = (int*) malloc(2*sizeof(int));
	endip2 = (int*) malloc(2*sizeof(int));
	endip3 = (int*) malloc(2*sizeof(int));
	endip4 = (int*) malloc(2*sizeof(int));

	//for(int i =0; i< 101 ; i++){
	//	shared_mem[i] = 0;
	//}
	shared_mem[GO_ON] = 1;
	printf("hi \n");
	printf("blaze 1 %d \n", shared_mem[M1_ON]);
	printf("blaze 2 %d \n", shared_mem[M2_ON]);
	printf("blaze 3 %d \n", shared_mem[M3_ON]);
	printf("blaze 4 %d \n", shared_mem[M4_ON]);


	shared_mem[M1_ON] = 0;
	shared_mem[M2_ON] = 0;
	shared_mem[M3_ON] = 0;
	shared_mem[M4_ON] = 0;

	initPeripherals();

	printf("hi \n");

	/************** mount sd card *****************/
	TCHAR *Path = "0:/";
	FRESULT  result;
	result = f_mount(&FS_instance,Path, 0);
	if (result != FR_OK) {
		printf("Cannot mount sd\n");
		return EXIT_FAILURE;
	}
	printf("sd card ok \n");

	for(int i =1; i< 101 ; i++){
		printf("%d,", shared_mem[i-1]);
		if(i%10 == 0){
			printf("\n");
		}
	}
	printf("\n");

	union{float* valin ; int valout;}converterf;
	union{int* valin ; int valout;}converteri;

	shared_mem[PCLUS] = (float*) centroids;
	converteri.valin = (int*) res;
	shared_mem[PRESU] = converteri.valout;
	converterf.valin = data_set;
	shared_mem[PDSET] = converter.valout;
	converterf.valin = centroids1;
	shared_mem[PCEN1] = converterf.valout;
	shared_mem[PCEN2] = (float*) centroids2;
	shared_mem[PCEN3] = (float*) centroids3;
	shared_mem[PCEN4] = (float*) centroids4;
	shared_mem[PEND1] = (int*) endip1;
	shared_mem[PEND2] = (int*) endip2;
	shared_mem[PEND3] = (int*) endip3;
	shared_mem[PEND4] = (int*) endip4;
	shared_mem[PNPOI] = (int)N_POINTS;
	shared_mem[PNPOIP] = (int)N_POINTS_IP;




	for(int i =1; i< 101 ; i++){
		printf("%d,", shared_mem[i-1]);
		if(i%10 == 0){
			printf("\n");
		}
	}
	printf("\n");
	kmeans();

	printf("done \n");

	free(data_set);
	free(res);
	free(centroids);
	free(centroids1);
	free(centroids2);
	free(centroids3);
	free(centroids4);
	free(endip);
	free(endip1);
	free(endip2);
	free(endip3);
	free(endip4);

	return 0;

}
