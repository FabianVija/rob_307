#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "xil_printf.h"
#include "xil_io.h"
#include "xdijkstra.h"
#include "xaxidma.h"
#include "xtmrctr.h"
#include "xparameters.h"

// Constants
#define N_TESTS 1000
#define CHUNK 16384
#define N_POINTS 10000
#define MAX_VALUE 10
#define N_IP_POINTS 1000000

// IPs
XTmrCtr timer;
XDijkstra dijkstra;
XDijkstra_Config *dijkstra_cfg;
XAxiDma axiDMA;
XAxiDma_Config *axiDMA_cfg;

// Data
int graph[N_POINTS][N_POINTS];
int hw_dist[N_IP_POINTS];
bool hw_Dset[N_IP_POINTS];
int hw_path[N_IP_POINTS];
int sw_result[N_POINTS];

void initPeripherals(){
	// Dijkstra
	dijkstra_cfg = XDijkstra_LookupConfig(XPAR_DIJKSTRA_0_DEVICE_ID);
	if(dijkstra_cfg){
		int status = XDijkstra_CfgInitialize(&dijkstra, dijkstra_cfg);
		if(status != XST_SUCCESS){
			printf("Error count core init \n");
		}
	}

	// Memory
	axiDMA_cfg = XAxiDma_LookupConfig(XPAR_AXIDMA_0_DEVICE_ID);
	if(axiDMA_cfg){
		unsigned int stat = XAxiDma_CfgInitialize(&axiDMA,axiDMA_cfg);
		if(stat != XST_SUCCESS){
			printf("error dma init \n");
		}
	}
	XAxiDma_IntrDisable(&axiDMA, XAXIDMA_IRQ_ALL_MASK, XAXIDMA_DEVICE_TO_DMA);
	XAxiDma_IntrDisable(&axiDMA, XAXIDMA_IRQ_ALL_MASK, XAXIDMA_DMA_TO_DEVICE);

	// Timer
	XTmrCtr_Initialize(&timer, XPAR_TMRCTR_0_DEVICE_ID);

}

int doDijkstra (int* arr, int size){
	int ip_size;
	int result=0;

    for (int i=0;i<size;i+=N_IP_POINTS){
    	//printf("i=%d\n",i);
    	// Size send
    	if (size-i<N_IP_POINTS)
    		ip_size = size%N_IP_POINTS;
    	else
    		ip_size = N_IP_POINTS;

    	// Call IP
		//result += sendIP(&arr[i],ip_size,filter);
    	// Start IP
		XCount_Set_size(&count,ip_size);
		XCount_Set_filter(&count,filter);
		XCount_Start(&count);

		// Update Cash
		Xil_DCacheFlushRange((u32)arr, (N_POINTS)*sizeof(int));
		Xil_DCacheFlushRange((u32)vector, (N_POINTS)*sizeof(int));
		Xil_DCacheFlushRange((u32)&result_ip, sizeof(int));
		Xil_DCacheFlushRange((u32)&filter, sizeof(int));

		// Send data
		XAxiDma_SimpleTransfer(&axiDMA, (u32) arr, ip_size*sizeof(int),XAXIDMA_DMA_TO_DEVICE );
		while(XAxiDma_Busy(&axiDMA, XAXIDMA_DMA_TO_DEVICE));
		//printf("send ip ok\n");

		// Receive data
		XAxiDma_SimpleTransfer(&axiDMA, (u32) &result_ip, sizeof(int),XAXIDMA_DEVICE_TO_DMA );
		while(XAxiDma_Busy(&axiDMA, XAXIDMA_DEVICE_TO_DMA));
		//	printf("receive ip ok\n");

		Xil_DCacheInvalidateRange((u32) &result_ip, sizeof(int));

		result +=result_ip;
    }

//	// Start IP
//	XCount_Set_size(&count,size);
//	XCount_Set_filter(&count,filter);
//	XCount_Start(&count);
//
//	// Update Cash
//	Xil_DCacheFlushRange((u32)arr, (N_POINTS)*sizeof(int));
//	Xil_DCacheFlushRange((u32)&result_ip, sizeof(int));
//	Xil_DCacheFlushRange((u32)&filter, sizeof(int));
//
//	// Send data
//	XAxiDma_SimpleTransfer(&axiDMA, (u32) arr, size*sizeof(int),XAXIDMA_DMA_TO_DEVICE );
//	while(XAxiDma_Busy(&axiDMA, XAXIDMA_DMA_TO_DEVICE));
//	//printf("send ip ok\n");
//
//	// Receive data
//	XAxiDma_SimpleTransfer(&axiDMA, (u32) &result_ip, sizeof(int),XAXIDMA_DEVICE_TO_DMA );
//	while(XAxiDma_Busy(&axiDMA, XAXIDMA_DEVICE_TO_DMA));
//	//	printf("receive ip ok\n");
//
//	Xil_DCacheInvalidateRange((u32) &result_ip, sizeof(int));

	return result;
}

void doDijkstra(unsigned int graph[max_vertex][max_vertex], unsigned int sw_result[max_vertex], unsigned int size, unsigned int src, unsigned int dstn) {
	unsigned int dist[max_vertex];	// distance to source
	bool Dset[max_vertex];	// Visited vertex list

	unsigned int min;	// Auxiliar variable - minimum distance
	unsigned int index;	// Auxiliar variable - index of minimum distance

	/* Initialize the vector values and source distance */
	//printf("start initialization of values\n");
	for(unsigned int i = 0; i < size; i++) {
		sw_result[i] = INT_MAX;
		dist[i] = INT_MAX;
		Dset[i] = false;
	}

	/*Initialize the distance of the source vertec to zero*/
	dist[src] = 0;

	//printf("start algorithm\n");
	for(unsigned int c = 0; c < size; c++)
	{
		min = INT_MAX;
		/* get the index of the vertex that has the minimum distance which has not yet been chosen*/
		for(unsigned int z = 0; z < size; z++) {
			if( (Dset[z] == false) && (dist[z] <= min) ) {
				min   = dist[z];
				index = z;
			}
		}
		/* If we have chosen the destiny vertex, stop the algorithm and send the result*/
		if(index == dstn) break;
		/* If the vertex with minimum distance was found, include it to Dset */
		Dset[index] = true;

		for(unsigned int v = 0; v < size; v++) {
			/*
			   Update dist[v] if not in Dset and their is a path from src to v through index
			   that has distance minimum than current value of dist[v]
			*/
			if( (!Dset[v] && graph[index][v]) && (dist[index] != INT_MAX) && (dist[index]+graph[index][v] < dist[v]) ) {
				dist[v] = dist[index] + graph[index][v];
				sw_result[v] = index;
			}
		}
	}
	sw_result[src] = 0;
}

void printResult(unsigned int sw_result[max_vertex], unsigned int size, unsigned int scr, unsigned int dstn){
	printf("source : %d, destination : %d, way : \n",scr,dstn);
	unsigned int i ;
	for (i=0;i<size;i++){
		printf("%d ",sw_result[i]);
	}
	printf("\n");
}

int main(){
	printf("Hi!!!\n");

	initPeripherals();

	uint32_t readStartTime;
	uint32_t readStopTime;
	uint32_t calculStartTime;
	uint32_t calculStopTime;
	float calculTime = 0;
	float readTime =0;
	double calculClock= 0;
	double readClock = 0;

	unsigned int src = 0;
	unsigned int dstn = 4;

	int i,number;
	for (i=0;i<N_TESTS;i++){

		printf("n=%d\n",i);
		XTmrCtr_Reset(&timer, 0);
		XTmrCtr_Start(&timer, 0);
		readStartTime = XTmrCtr_GetValue(&timer,0);

		//--------------------------------------- Read data
		// Create data
		for(int m = 0; m < N_POINTS; m++) {
					for(int n = 0; n < N_POINTS; n++) {
						graph[m][n] = ((unsigned int)rand()) % MAX_DIST;
					}
		}
		src = rand() % max_vertex;
		dstn = rand() % max_vertex;

		//-------------------------------------- Dijkstra

		//printf("doing...\n");
		calculStartTime = XTmrCtr_GetValue(&timer,0);
		doDijkstra(graph, sw_result, N_POINTS, src, dstn);
		calculStopTime = XTmrCtr_GetValue(&timer,0);
		readStopTime = XTmrCtr_GetValue(&timer,0);
		//printf("dijkstra done\n");

		//-------------------------------------- Time

		// Print data
		//printResult(sw_result,max_vertex,src,dstn	);

		XTmrCtr_Stop(&timer, 0);

		calculClock += (calculStopTime - calculStartTime);
		readClock += (readStopTime - readStartTime);
		calculTime += ((calculStopTime - calculStartTime) / (XPAR_TMRCTR_0_CLOCK_FREQ_HZ / (double) 1000.0));
		readTime += ((readStopTime - readStartTime) / (XPAR_TMRCTR_0_CLOCK_FREQ_HZ / (double) 1000.0));
	}

	calculClock = calculClock/N_TESTS;
	readClock = readClock/N_TESTS;
	calculTime = calculTime/N_TESTS;
	readTime = readTime/N_TESTS;

	printf("Number of tests: %d\n",N_TESTS);
	printf("Size of vector: %d\n",N_POINTS);
	printf("Frequence : %u\n",XPAR_TMRCTR_0_CLOCK_FREQ_HZ);
	printf("Time of calcul: %f ms\n",calculTime);
	printf("Clocks of calcul: %f\n", calculClock);
	printf("Time total: %f ms\n",readTime);
	printf("Clocks total: %f\n", readClock);

	printf("done \n");
	return 0;

}
