#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "ff.h"
#include "xil_printf.h"
#include "xil_io.h"
#include "xquicksortiterativev2.h"
#include "xaxidma.h"
#include "xtmrctr.h"
#include "xparameters.h"

// Constantes
#define N_TESTS 1
#define CHUNK 16384
#define N_POINTS 100
#define N_IP_POINTS 20

// vectors
int vector[N_POINTS];
int aux_vec[N_POINTS];
int ip_vec[N_IP_POINTS];
int pivot;

// IPs
XTmrCtr timer;
XQuicksortiterativev2 sort;
XQuicksortiterativev2_Config *sort_cfg;
XAxiDma axiDMA;
XAxiDma_Config *axiDMA_cfg;

// File
static char fileName[]="data10e3.txt";
static FATFS  FS_instance;
static FIL file_in;

void initPeripherals(){
	// QuickSort
	sort_cfg = XQuicksortiterativev2_LookupConfig(XPAR_QUICKSORTITERATIVEV2_0_DEVICE_ID);
	if(sort_cfg){
		int status = XQuicksortiterativev2_CfgInitialize(&sort, sort_cfg);
		if(status != XST_SUCCESS){
			printf("Error count core init \n");
		}
	}

	// Memory
	axiDMA_cfg = XAxiDma_LookupConfig(XPAR_AXIDMA_0_DEVICE_ID);
	if(axiDMA_cfg){
		unsigned int stat = XAxiDma_CfgInitialize(&axiDMA,axiDMA_cfg);
		if(stat != XST_SUCCESS){
			printf("error dma init \n");
		}
	}
	XAxiDma_IntrDisable(&axiDMA, XAXIDMA_IRQ_ALL_MASK, XAXIDMA_DEVICE_TO_DMA);
	XAxiDma_IntrDisable(&axiDMA, XAXIDMA_IRQ_ALL_MASK, XAXIDMA_DMA_TO_DEVICE);

	// Timer
	XTmrCtr_Initialize(&timer, XPAR_TMRCTR_0_DEVICE_ID);

}

// A utility function to print contents of arr
void printArr( int arr[], int n ){
    int i;
    for ( i = 0; i < n-1; i++ )
        printf( "%d, ", arr[i] );
    printf( "%d\n", arr[n-1] );

}

void createRandomVector(){
	//int max_val = 100000000;
	int max_val = 100;
	printf("creating elements...\n");

	int i = 0;
	for (i=0;i<N_POINTS;i++){
		vector[i]=rand() % max_val;
		//printf ("%d\n", vector[i]);
	}
	printf("finished create Elements\n");

}

int IP(int* array, int* ip_vec, int size, int pivot) {
	int c1 = 0;
	int c2 = 0;
	int c3 = 0;
	int aux[N_POINTS];
	for(int i = 0; i < size; i++) {
		if(array[i] <= pivot) {
			ip_vec[c1] = array[i];
			c1++;
		} else {
			aux[c2] = array[i];
			c2++;
		}
	}

    // printf("array ip_vec plus petit\n");
    // printArr(ip_vec, size);
    // printf("array ip_vec plus grand\n");
    // printArr(aux, size);

	for(int i = c1; i < size; i++) {
		ip_vec[i] = aux[i-c1];
	}
	return c1;
}

int partition (int* arr, int l, int h){
	int ip_size;
	int index,index_min=l,index_max=h;
	int size = h-l+1;
	int pivot = arr[h];

    //printf("patition start...\n");
	for (int i=0;i<size-1;i+=N_IP_POINTS){
    	// printf("i=%d\n",i);

		// Size send
		if (size-1-i<N_IP_POINTS)
			ip_size = size-1-i;
		else
			ip_size = N_IP_POINTS;

		// Start IP
        // printf("pivot=%d,ip_size=%d       array send\n",pivot,ip_size);
        // printArr(&arr[l+i], ip_size);
		index = IP(&arr[l+i], ip_vec, ip_size, pivot);
        // printf("index=%d, array reveid\n",index);
        // printArr(ip_vec, ip_size);

		for(int j=0;j<index;j++){
			aux_vec[index_min]=ip_vec[j];
			index_min++;
		}

		for(int j=ip_size-1;j>=index;j--){
			aux_vec[index_max]=ip_vec[j];
			index_max--;
		}


        // printf("array vec aux intermediaire\n");
        // printArr(aux_vec, N_POINTS);
	}

	for(int j=l;j<=h;j++){
		vector[j]=aux_vec[j];
	}
	vector[index_min]=pivot;

    // printf("array vec aux \n");
    // printArr(&aux_vec[l], size);
    // printf("array vector fin \n");
    // printArr(&vector[l], size);

    for(int j=0;j<=N_POINTS;j++){
		aux_vec[j]=0;
	}

	return index_min;
}

/* A[] --> Array to be sorted,
   l  --> Starting index,
   h  --> Ending index */
void quickSortIterative (int arr[], int l, int h){
    // Create an auxiliary stack
    int* stack;
    stack = (int*) malloc ((h - l + 1)*sizeof(int));

    // initialize top of stack
    int top = -1;

    // push initial values of l and h to stack
    stack[ ++top ] = l;
    stack[ ++top ] = h;

    // Keep popping from stack while is not empty
    while ( top >= 0 )
    //for(int i=0;i<5;i++)
    {
        // Pop h and l
        h = stack[ top-- ];
        l = stack[ top-- ];

        // Set pivot element at its correct position
        // in sorted array
        int p = partition( arr, l, h );

        // If there are elements on left side of pivot,
        // then push left side to stack
        if ( p-1 > l )
        {
            stack[ ++top ] = l;
            stack[ ++top ] = p - 1;
        }

        // If there are elements on right side of pivot,
        // then push right side to stack
        if ( p+1 < h )
        {
            stack[ ++top ] = p + 1;
            stack[ ++top ] = h;
        }
    }
    free (stack);
}

int main(){
    printf("Hi!!!\n");
	for (int i=0;i<N_TESTS;i++){
        printf("reading...\n");
        //createVector(fileName);
        createRandomVector();
		int vector2[N_POINTS];
		for(int i = 0; i < N_POINTS; i++) {
			vector2[i] = vector[i];
		}
        printf("reade done\n");
        printArr(vector,N_POINTS);
		//-------------------------------------- Sorting
		printf("sorting...\n");
		quickSortIterative(vector,0,N_POINTS-1);
		printf("sort done\n");
		printArr(vector,N_POINTS);

		//-------------------------------------- Time
		std::sort(vector2, vector2+N_POINTS);
		printArr(vector2,N_POINTS);

		for(int i = 0; i < N_POINTS; i++) {
			if(vector[i] != vector2[i]) {
				printf("!= error, i = %i, vector[i] = %i, vector2[i] = %i\n", i, vector[i], vector2[i]);

			}
		}

	}

	printf("done \n");
	return 0;

}
