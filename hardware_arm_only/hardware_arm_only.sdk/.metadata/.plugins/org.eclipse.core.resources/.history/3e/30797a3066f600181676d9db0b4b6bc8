using namespace std;
#include <time.h>       /* clock_t, clock, CLOCKS_PER_SEC */
#include <chrono>
#define INT_MAX 2147483647
#define max_vertex 100      /* It is the maximum number of vertices in the graph */

void find_diameter(int graph[max_vertex][max_vertex], unsigned int diameter, unsigned int size)
{
	unsigned int dist[max_vertex][max_vertex];
	bool Dset[max_vertex][max_vertex];
	diameter = 0;
	/*Initialize the distance of the source vertec to zero*/
	/* A method to initialize the vector values and source distance */
	for(int i = 0; i < size; i++)                    /* Initialize distance of all the vertex to INFINITY and Dset as false */
	{
		for(int j = 0; j < size; j++) {
			dist[i][j] = INT_MAX;
			Dset[i][j] = false;
		}
	}
	int min;
	int index;
	for(int src = 0; src < size; src++) {
		dist[src][src] = 0;      // Set the distance from the source to the source to zero.
		for(int c = 0; c < size; c++)
		{
			/* u is the index of any vertex that is not yet included in Dset and has minimum distance */
			min = INT_MAX;
			index = INT_MAX;
			for(int z = 0; z < size; z++)
			{
				if( (Dset[src][z] == false) && (dist[src][z] <= min) )
				{
					min   = dist[src][z];
					index = z;
				}
			}
			Dset[src][index] = true;  /* If the vertex with minimum distance was found, include it to Dset */

			for(int v = 0; v < size; v++)
			{
				/*
				Update dist[v] if not in Dset and their is a path from src to v through u
				that has distance minimum than current value of dist[v]
				*/
				if( (!Dset[src][v] && graph[index][v]) && (dist[src][index] != INT_MAX) && (dist[src][index]+graph[index][v] < dist[src][v]) ) {
					dist[src][v] = dist[src][index] + graph[index][v];
				}
			}
		}
	}
	for(int i = 0; i < size; i++)                    /* Initialize distance of all the vertex to INFINITY and Dset as false */
	{
		for(int j = 0; j < size; j++) {
			if(dist[i][j] > diameter) {
				diameter = dist[i][j];
			}
		}
	}
	return;
}

int main() {
	cout << "============================================================================" << endl;
	int graph[max_vertex][max_vertex];
	unsigned int diameter;
	std::chrono::duration<double> total_time = (std::chrono::duration<double>) 0.0;
	std::chrono::duration<double> duration = (std::chrono::duration<double>) 0.0;
	int N = 1000;
	unsigned int size = 100;
	std::chrono::time_point<std::chrono::system_clock> start, end;
	clock_t t;
	for(int i = 0; i < N; i++) {
		for(int m = 0; m < size; m++) {
			for(int n = 0; n < size; n++) {
				graph[m][n] = rand() % 2;
			}
		}
		auto start = std::chrono::high_resolution_clock::now();
		find_diameter(graph, diameter, size);
		auto finish = std::chrono::high_resolution_clock::now();
		duration =(finish-start);
		//std::cout << std::chrono::duration_cast<std::chrono::nanoseconds>(finish-start).count() << "ns\n";
		//auto duration = duration_cast<microseconds>( t2 - t1 ).count();
		//cout << duration << ", ";
		total_time += duration;
	}
	cout << endl;
	cout << endl;
	cout << "avg_time = " << 1000*(total_time.count())/N << "mS" << endl;
	return 0;
}
